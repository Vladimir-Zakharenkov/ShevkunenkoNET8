The first filter selects all the products with a price of $20 or more, and 
the second filter selects products whose name starts with the letter S. 
You will see the following output in the browser window if you run the
example application:

Price Total: $358.90
Name Total: $19.50

Defining Functions

I can repeat this process indefinitely to create filter methods for every property 
and every combination of properties that I am interested in. A more elegant approach 
is to separate the code that processes the enumeration from the selection criteria. 
C# makes this easy by allowing functions to be passed around as objects. Listing 5-37 
shows a single extension method that filters an enumeration of Product objects but that
delegates the decision about which ones are included in the results to a separate function.

Listing 5-37. Creating a General Filter Method in the MyExtensionMethods.cs File 
in the Models Folder

namespace LanguageFeatures.Models {

	public static class MyExtensionMethods {

		public static decimal TotalPrices(this IEnumerable<Product?> products) {
				decimal total = 0;
				foreach (Product? prod in products) {
					total += prod?.Price ?? 0;
			}
			return total;
		}

		public static IEnumerable<Product?> FilterByPrice(
		this IEnumerable<Product?> productEnum, decimal minimumPrice) {

			foreach (Product? prod in productEnum) {
				if ((prod?.Price ?? 0) >= minimumPrice) {
					yield return prod;
				}
			}
		}

		public static IEnumerable<Product?> Filter(
			this IEnumerable<Product?> productEnum,
				Func<Product?, bool> selector) {
				
				foreach (Product? prod in productEnum) {
					if (selector(prod)) {
						yield return prod;
				}
			}
		}
	}
}
The second argument to the Filter method is a function that accepts 
a Product? object and that returns a bool value. The Filter method calls 
the function for each Product? object and includes it in the result if 
the function returns true. To use the Filter method, I can specify a method 
or create a stand-alone function, as shown in Listing 5-38.

Listing 5-38. Using a Function to Filter Objects in the HomeController.cs File 
in the Controllers Folder

namespace LanguageFeatures.Controllers {
	public class HomeController : Controller {

		bool FilterByPrice(Product? p) {
			return (p?.Price ?? 0) >= 20;
		}

		public ViewResult Index() {

			ShoppingCart cart = new ShoppingCart { Products = Product.GetProducts()};

			Product[] productArray = {
				new Product {Name = "Kayak", Price = 275M},
				new Product {Name = "Lifejacket", Price = 48.95M},
				new Product {Name = "Soccer ball", Price = 19.50M},
				new Product {Name = "Corner flag", Price = 34.95M}
			};

			Func<Product?, bool> nameFilter = delegate (Product? prod) {
				return prod?.Name?[0] == 'S';
			};

			decimal priceFilterTotal = productArray
				.Filter(FilterByPrice)
				.TotalPrices();

			decimal nameFilterTotal = productArray
				.Filter(nameFilter)
				.TotalPrices();

			return View("Index", new string[] {
				$"Price Total: {priceFilterTotal:C2}",
				$"Name Total: {nameFilterTotal:C2}" });
		}
	}
}

Neither approach is ideal. Defining methods like FilterByPrice clutters up 
a class definition. Creating a Func<Product?, bool> object avoids this problem 
but uses an awkward syntax that is hard to read and hard to maintain. It is 
this issue that lambda expressions address by allowing functions to be defined 
in a more elegant and expressive way, as shown in Listing 5-39.