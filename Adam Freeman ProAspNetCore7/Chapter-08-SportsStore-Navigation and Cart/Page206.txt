The next behavior I want to test is the ability to calculate the total cost of the items in the cart. Here’s
the test for this behavior:

...
[Fact]
        public void Calculate_Cart_Total()
        {
            // Arrange - create some test products
            Product p1 = new Product { ProductID = 1, Name = "P1", Price = 100M };
            Product p2 = new Product { ProductID = 2, Name = "P2", Price = 50M };

            // Arrange - create a new cart
            Cart target = new Cart();

            // Act
            target.AddItem(p1, 1);
            target.AddItem(p2, 1);
            target.AddItem(p1, 3);

            decimal result = target.ComputeTotalValue();

            // Assert
            Assert.Equal(450M, result);
        }
...

The final test is simple. I want to ensure that the contents of the cart are properly removed when reset.
Here is the test:

...
[Fact]
        public void Can_Clear_Contents()
        {
            // Arrange - create some test products
            Product p1 = new Product { ProductID = 1, Name = "P1", Price = 100M };
            Product p2 = new Product { ProductID = 2, Name = "P2", Price = 50M };

            // Arrange - create a new cart
            Cart target = new Cart();

            // Arrange - add some items
            target.AddItem(p1, 1);
            target.AddItem(p2, 1);

            // Act - reset the cart
            target.Clear();

            // Assert
            Assert.Empty(target.Lines);
        }
...

Sometimes, as in this case, the code required to test the functionality of a class is longer and more
complex than the class itself. Do not let that put you off writing the unit tests. Defects in simple classes
can have huge impacts, especially ones that play such an important role as Cart does in the example
application.